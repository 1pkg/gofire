// THIS IS AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Generated using github.com/1pkg/gofire ðŸ”¥ 2021-10-24T12:28:27+02:00.
package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"os"
	"os/signal"
	"strings"
	"unicode"

	"github.com/1pkg/gofire"
	"github.com/1pkg/gofire/parsers"
	"github.com/mitchellh/mapstructure"
)

// CommandGofire is autogenerated cli interface for Gofire function.
func CommandGofire(ctx context.Context) (err error) {
	var driver *string
	var pckg *string
	var a0 string
	var a1 string
	if err = func(ctx context.Context) (err error) {
		help := func() {
			doc, usage, list := "Gofire ðŸ”¥ is command line interface generator tool.\nThe first required argument dir represents directory path of source package.\nThe second required argument fun represents source function name.\nOptional flag driver represents driver backend name, one of [gofire, flag, pflag, cobra, bubbletea], flag by default.\nOptional flag pckg represents source package name, useful if package name and directory is different, last element of dir by default.", "Gofire --driver=\"\" --pckg=\"\" arg0 arg1 [--help]", "func Gofire(ctx context.Context, driver, pckg *string, dir, fun string), --driver string (default \"\") --pckg string (default \"\") arg 0 string arg 1 string"
			if doc != "" {
				_, _ = fmt.Fprintln(flag.CommandLine.Output(), doc)
			}
			if usage != "" {
				_, _ = fmt.Fprintln(flag.CommandLine.Output(), usage)
			}
			if list != "" {
				_, _ = fmt.Fprintln(flag.CommandLine.Output(), list)
			}
		}
		defer func() {
			if err != nil {
				help()
			}
		}()
		var tokenize = func(tokens []string) (args []string, flags map[string]string, err error) {
			var flname = func(token string) (string, error) {
				fln := strings.Replace(token, "--", "", 1)
				for _, r := range fln {
					if r != '.' && !(unicode.IsLetter(r) || unicode.IsDigit(r)) {
						return "", fmt.Errorf("flag name %s is not alphanumeric and can't be tokenized", fln)
					}
				}
				if _, ok := flags[fln]; ok {
					return "", fmt.Errorf("flag name %s used multiple times and can't be tokenized", fln)
				}
				return fln, nil
			}
			ltkns := len(tokens)
			args, flags = make([]string, 0, ltkns), make(map[string]string, ltkns)
			var fln, prevToken string
			for i := 0; i < ltkns; i++ {
				token := strings.TrimSpace(tokens[i])
				if token == "" {
					continue
				}
				iflag, iflagPrev := strings.HasPrefix(token, "--"), strings.HasPrefix(prevToken, "--")
				f, _ := flname(token)
				switch {
				case !iflag && !iflagPrev:
					if strings.HasPrefix(token, "-") {
						err = fmt.Errorf("short flag name %s can't be tokenized", token)
					} else {
						args = append(args, token)
						prevToken = ""
					}
				case iflag && strings.Contains(token, "="):
					parts := strings.SplitN(token, "=", 2)
					fln, err = flname(parts[0])
					flags[fln] = parts[1]
					prevToken = ""
				case !iflag && iflagPrev:
					fln, err = flname(prevToken)
					flags[fln] = token
					prevToken = ""
				case f == "help":
					args, flags = nil, map[string]string{"help": "true"}
					return
				case iflag && i != ltkns-1:
					prevToken = token
				default:
					err = fmt.Errorf("provided cli parameters %v can't be tokenized near token %s %s", tokens, prevToken, token)
				}
				if err != nil {
					args, flags = nil, nil
					return
				}
			}
			return
		}
		args, flags, err := tokenize(os.Args[1:])
		if err != nil {
			return err
		}
		if args == nil {
			args = nil
		}
		if flags == nil {
			flags = nil
		}
		if flags["help"] == "true" {
			return errors.New("help requested")
		}
		{
			f, ok := flags["driver"]
			v, set, err := parsers.ParseTypeValue(gofire.TPrimitive{TKind: 0x10}, f)
			if err != nil {
				return fmt.Errorf("flag driver value %v can't be parsed %v", f, err)
			}
			if !ok || !set {
				t := ""
				v = &t
			}
			var t string
			if err := mapstructure.Decode(v, &t); err != nil {
				return fmt.Errorf("flag driver value %v can't be decoded %v", v, err)
			}
			driver = &t
		}
		{
			f, ok := flags["pckg"]
			v, set, err := parsers.ParseTypeValue(gofire.TPrimitive{TKind: 0x10}, f)
			if err != nil {
				return fmt.Errorf("flag pckg value %v can't be parsed %v", f, err)
			}
			if !ok || !set {
				t := ""
				v = &t
			}
			var t string
			if err := mapstructure.Decode(v, &t); err != nil {
				return fmt.Errorf("flag pckg value %v can't be decoded %v", v, err)
			}
			pckg = &t
		}
		{
			i := 0
			if len(args) <= i {
				return fmt.Errorf("argument %d-th is required", i)
			}
			v, _, err := parsers.ParseTypeValue(gofire.TPrimitive{TKind: 0x10}, args[i])
			if err != nil {
				return fmt.Errorf("argument a0 value %v can't be parsed %v", args[i], err)
			}
			if err := mapstructure.Decode(v, &a0); err != nil {
				return fmt.Errorf("argument a0 value %v can't be decoded %v", v, err)
			}
		}
		{
			i := 1
			if len(args) <= i {
				return fmt.Errorf("argument %d-th is required", i)
			}
			v, _, err := parsers.ParseTypeValue(gofire.TPrimitive{TKind: 0x10}, args[i])
			if err != nil {
				return fmt.Errorf("argument a1 value %v can't be parsed %v", args[i], err)
			}
			if err := mapstructure.Decode(v, &a1); err != nil {
				return fmt.Errorf("argument a1 value %v can't be decoded %v", v, err)
			}
		}
		return
	}(ctx); err != nil {
		return
	}
	Gofire(ctx, driver, pckg, a0, a1)
	return
}

// auto generated main entrypoint.
func main() {
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()
	func(err error) {
		if err != nil {
			fmt.Println(err)
			os.Exit(2)
		}
	}(CommandGofire(ctx))
}
